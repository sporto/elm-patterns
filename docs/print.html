<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Elm Patterns</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Elm patterns</a></li><li class="chapter-item expanded "><strong aria-hidden="true">2.</strong> Basic patterns</li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/type-blindness.html"><strong aria-hidden="true">2.1.</strong> Type blindness</a></li><li class="chapter-item expanded "><a href="basic/named-arguments.html"><strong aria-hidden="true">2.2.</strong> Named arguments</a></li><li class="chapter-item expanded "><a href="basic/wrap-early.html"><strong aria-hidden="true">2.3.</strong> Wrap early, unwrap late</a></li><li class="chapter-item expanded "><a href="basic/unwrap-maybe-early.html"><strong aria-hidden="true">2.4.</strong> Unwrap maybe early</a></li><li class="chapter-item expanded "><a href="basic/builder-pattern.html"><strong aria-hidden="true">2.5.</strong> The builder pattern</a></li><li class="chapter-item expanded "><a href="basic/impossible-states.html"><strong aria-hidden="true">2.6.</strong> Make impossible states impossible</a></li><li class="chapter-item expanded "><a href="basic/parse-dont-validate.html"><strong aria-hidden="true">2.7.</strong> Parse don't validate</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">3.</strong> Advanced patterns</li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/railway.html"><strong aria-hidden="true">3.1.</strong> Railway</a></li><li class="chapter-item expanded "><a href="advanced/pipeline-builder.html"><strong aria-hidden="true">3.2.</strong> Pipeline builder</a></li><li class="chapter-item expanded "><a href="advanced/opaque-types.html"><strong aria-hidden="true">3.3.</strong> Opaque types</a></li><li class="chapter-item expanded "><a href="advanced/opaque-types-invariants.html"><strong aria-hidden="true">3.4.</strong> Opaque types for enforcing invariants</a></li><li class="chapter-item expanded "><a href="advanced/flow-phantom-types.html"><strong aria-hidden="true">3.5.</strong> Process flow using phantom types</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">4.</strong> Architecture</li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/nested-tea.html"><strong aria-hidden="true">4.1.</strong> Nested TEA</a></li><li class="chapter-item expanded "><a href="architecture/global-actions.html"><strong aria-hidden="true">4.2.</strong> Global actions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Elm Patterns</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/sporto/elm-patterns" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#elm-patterns" id="elm-patterns">Elm patterns</a></h1>
<p>A collection of common patterns for Elm</p>
<h1><a class="header" href="#type-blindness" id="type-blindness">Type blindness</a></h1>
<p>Type blindness is when you have several values of the same type that could get mixed up.</p>
<p><strong>Example 1</strong></p>
<pre><code class="language-haskell">type alias User =
  { firstName: String, lastName: String }
</code></pre>
<p>Both attributes are <code>String</code>. It is easy to mix them up when receiving external information. </p>
<p><strong>Example 2</strong></p>
<pre><code class="language-haskell">priceInDollars : Float
priceInDollars = 2.0

priceInEuros : Float
priceInEuros = 1
</code></pre>
<p>Both values are <code>Float</code>. There is nothing preventing us from doing a non sensical operation like <code>priceInDollars + priceInEuros</code>.</p>
<h2><a class="header" href="#pattern" id="pattern">Pattern</a></h2>
<p>In this case consider wrapping values in a unique type.</p>
<pre><code class="language-haskell">type Dollar = Dollar Float

priceInDollars : Dollar
priceInDollar =
  Dollar 2.0
</code></pre>
<p>You will need to unwrap values later, which can get tedious, so use this when there is a good potential of mixing up values. </p>
<h1><a class="header" href="#named-arguments" id="named-arguments">Named arguments</a></h1>
<p>There are times when the order of arguments for a functions can be ambiguous. For example:</p>
<pre><code class="language-haskell">isBefore : Date -&gt; Date -&gt; Bool
</code></pre>
<p>What is the subject date here and the comparison date? </p>
<p>As we usually put the data at the end (for pipelines) we might think that the subject is the second date, but maybe is not. This is vague and error prone.</p>
<p>In this cases is better if we ask for a record as argument:</p>
<pre><code class="language-haskell">isBefore : { subject: Date, comparedTo: Date } -&gt; Bool
</code></pre>
<p>This might not be pipeline friendly, but it is a lot more precise and hard to get wrong.</p>
<h1><a class="header" href="#wrap-early-unwrap-late" id="wrap-early-unwrap-late">Wrap early, unwrap late</a></h1>
<p>To avoid type blidness, you probably want to wrap your values in unique types.</p>
<p>When you do this it is a good idea to wrap your types as early as possible. E.g. when decoding values from external sources.</p>
<p>Then try to unwrap as late as possible.</p>
<h2><a class="header" href="#example-anti-patterns" id="example-anti-patterns">Example anti-patterns</a></h2>
<pre><code class="language-elm">displayPriceInDollars : Float -&gt; String
displayPriceInDollars price =
    &quot;USD$&quot; ++ String.fromFloat price
</code></pre>
<p>There is nothing stopping us from passing something that is not dollars here (e.g. we might use Euros).</p>
<pre><code class="language-elm">calculateTotalPrice: List Float -&gt; Float
</code></pre>
<p>We could send a list of mixed currencies e.g. dollars and euros.</p>
<h2><a class="header" href="#pattern-1" id="pattern-1">Pattern</a></h2>
<pre><code class="language-elm">type Dollar = Dollar Float

displayPriceInDollars : Dollar -&gt; String
displayPriceInDollars (Dollar price) =
    &quot;USD$&quot; ++ String.fromFloat price
</code></pre>
<p>This enforces that we use the <code>Dollar</code> type as much as possible.</p>
<h1><a class="header" href="#unwrap-maybe-and-result-early" id="unwrap-maybe-and-result-early">Unwrap Maybe and Result early</a></h1>
<p>If you have a <code>Maybe</code>, <code>Result</code> or <code>RemoteData</code> it is often a good idea to try to unwrap those as early as possible.</p>
<h2><a class="header" href="#anti-pattern" id="anti-pattern">Anti-pattern</a></h2>
<pre><code class="language-elm">userCard : Maybe User -&gt; Html Msg
userCard maybeUser =
   div []
        [ userInfo maybeUser
        , userActivity maybeUser
        ]
</code></pre>
<p>In here both <code>userInfo</code> and <code>userActivy</code> get a <code>Maybe User</code>. Meaning that will need to unwrap this value several times in your views.</p>
<h2><a class="header" href="#pattern-2" id="pattern-2">Pattern</a></h2>
<pre><code class="language-elm">userCard maybeUser =
    case maybeUser of
        Nothing -&gt;
            div [] [ ... ]
        Just user -&gt;
            div []
                [ userInfo user
                , userActivity user
                ]
</code></pre>
<p>Here the sub views take a <code>User</code>, this makes most of your views easier to write and test. </p>
<h1><a class="header" href="#the-builder-pattern" id="the-builder-pattern">The builder pattern</a></h1>
<p>When we need to pass many arguments to a function we might have something like</p>
<pre><code class="language-elm">module Button exposing (..)

type alias Args =
    { isEnabled: Bool
    , label: String
    , hexColor: String
    , ...
    }

btn: Args -&gt; Html msg
</code></pre>
<p>In the caller module:</p>
<pre><code class="language-elm">import Button

Button.btn { isEnabled: True, label: &quot;Click me&quot;, ....}
</code></pre>
<p>The problem with this is that each time we add an argument to <code>Args</code> we need to change every single place where we call this function.</p>
<h2><a class="header" href="#pattern-3" id="pattern-3">Pattern</a></h2>
<p>With builder pattern we build the arguments with the minimum necessary information, then modify the arguments if we need to.</p>
<pre><code class="language-elm">module Button exposing (..)

newArgs: String -&gt; Args
newArgs label =
    { isEnabled = True
    , label = label
    , hexColor: &quot;#ABC&quot;
    , ...
    }

withIsEnabled : Bool -&gt; Args -&gt; Args
withIsEnabled isEnabled args =
    { args | isEnabled = isEnabled}

btn: Args -&gt; Html msg
</code></pre>
<p>This modules exposes a function to create the initial arguments and a series of function to modify the arguments (commonly using <code>with</code> as prefix).</p>
<p>Then the caller module uses this:</p>
<pre><code class="language-elm">import Button

aButton =
    Button.newArgs &quot;Click me&quot;
        |&gt; Button.withIsEnabled False
        |&gt; Button.withHexColor &quot;#123&quot;
        |&gt; Button.btn
</code></pre>
<p>The advantage of this is that adding new arguments to <code>Args</code> doesn't require us to change every caller.</p>
<h1><a class="header" href="#make-impossible-states-impossible" id="make-impossible-states-impossible">Make impossible states impossible</a></h1>
<p>Elm has a great and expressible type system. This type system allows us to avoid having impossible states in our application.</p>
<h2><a class="header" href="#anti-pattern-1" id="anti-pattern-1">Anti-pattern</a></h2>
<p>A common pattern is to have a boolean attribute to show a loading spinner while data is loading. e.g.</p>
<pre><code class="language-elm">type alias Model =
    { isLoading: Bool
    , data: Maybe Data
    }
</code></pre>
<p>But in this type is possible to have something like <code>isLoading = false</code> and <code>data = Nothing</code>. What is the meaning of this? This is probably an impossible state that should never happen.</p>
<h2><a class="header" href="#pattern-4" id="pattern-4">Pattern</a></h2>
<p>Which Elm you can represent your types in ways that don't allow for impossible states. e.g</p>
<pre><code class="language-elm">type RemoteData
    = Loading
    | Loaded Data

type alias Model =
    { data : RemoteData }
</code></pre>
<p><a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Here is an excellent talk about this</a>.</p>
<h1><a class="header" href="#parse-dont-validate" id="parse-dont-validate">Parse don't validate</a></h1>
<p>When we have external data (e.g. user input or remote data) it is a common pattern to validate this data before using it.</p>
<h2><a class="header" href="#anti-pattern-2" id="anti-pattern-2">Anti-pattern</a></h2>
<p>A common approach is to ask if the data is valid and then use it e.g.</p>
<pre><code class="language-elm">type alias UserInput =
    { name: Maybe String
    , age: Maybe Int
    }

isValidUser : UserInput -&gt; Bool
</code></pre>
<p>The problem with this approach is that after doing this you still have a <code>UserInput</code> with can still hold invalid values.</p>
<h2><a class="header" href="#pattern-5" id="pattern-5">Pattern</a></h2>
<p>A better approach is to &quot;parse&quot; your input and return a known valid type. e.g.</p>
<pre><code class="language-elm"> type alias UserInput =
    { name: Maybe String
    , age: Maybe Int
    }

type alias ValidUser =
    { name: String
    , age: Int
    }

validateUser : UserInput -&gt; Result String ValidUser
</code></pre>
<p>In this way you ensure that you have a valid type to work with later on. Some examples where this is useful:</p>
<ul>
<li>Validating user input</li>
<li>Parsing JSON from external sources</li>
</ul>
<h1><a class="header" href="#the-railway-pattern" id="the-railway-pattern">The railway pattern</a></h1>
<p>The railway pattern is a way of chaining operations where each might fail.
It is called railway because there are two tracks in this pattern.</p>
<ul>
<li>The first track is the happy path</li>
<li>The second track is the error track</li>
</ul>
<p>If any of the chained functions fails we move to the error track. From there we get an error at the end of the railway.</p>
<p>For example, let say we want to:</p>
<ul>
<li>Parse some external data</li>
<li>Validate the parsed data</li>
<li>Transform the data into something else</li>
</ul>
<pre><code class="language-haskell">parseData : String -&gt; Result String ParsedData

validateData : ParsedData -&gt; Result String ValidData

transformData : ValidData -&gt; Result String TransformedData
</code></pre>
<h2><a class="header" href="#pattern-6" id="pattern-6">Pattern</a></h2>
<p>In Elm this is commonly done using <code>Maybe.andThen</code> and <code>Result.andThen</code>. These function will run the next function in the chain if the previous function was successful, otherwise they will propagate the error.</p>
<pre><code class="language-haskell">process : String -&gt; Result String TransformedData
process data =
	parseData data
		|&gt; Result.andThen validateData
		|&gt; Result.andThen transformData
</code></pre>
<p><a href="https://fsharpforfunandprofit.com/rop/">Here is an excellent post about this with a lot more details</a>.</p>
<h2><a class="header" href="#variant" id="variant">Variant</a></h2>
<p>A variant of this is where the second track doesn't represent an error, but rather an early exit.</p>
<p>E.g. This process finds recommendations for a user. Each function in the chain can add to the recommendations or choose to exit the process.</p>
<pre><code class="language-haskell">type Process
	= Continue Recommendation
	| Exit Recommendation

andThen : (Recommendation -&gt; Process) -&gt; Process -&gt; Process
andThen callback process =
	case process of
		Continue document -&gt; callback document
		Exit document -&gt; Exit document

findRecommendations user =
	Continue emptyRecommendation
		|&gt; andThen (findMusic user)
		|&gt; andThen (findBooks user)
		|&gt; andThen (findMovies user)
		|&gt; andThen (findGames user)

findMusic : User -&gt; Recommendation -&gt; Process

...
</code></pre>
<p><code>andThen</code> is a function that mirrors <code>Result.andThen</code> but specific for <code>Process</code>.</p>
<h1><a class="header" href="#pipeline-builder" id="pipeline-builder">Pipeline builder</a></h1>
<p>This is a common pattern used for decoders and validation. This pattern is used to build a function for processing some data using a series of piped functions.</p>
<pre><code class="language-haskell">type alias User =
	{ name: String
	, age: Int
	}

validateUser : User -&gt; Result String User
validateUser user =
    Ok User
        |&gt; validateName user.name
        |&gt; validateAge user.age
</code></pre>
<p>This builds a function <code>validateUser</code> that will take a user and validate it. This <code>validateUser</code> function works like the railway pattern. We might get an <code>Ok User</code> at the end or an error <code>Err String</code>.</p>
<p>This pattern relies on the fact that a type alias in Elm can be used as a function. e.g. <code>User</code> is a function like:</p>
<pre><code class="language-haskell">String -&gt; Int -&gt; User
</code></pre>
<p>We start by putting the function (<code>User</code>) into a Result.</p>
<p>Then each function in the chain takes an attribute and the previous result, does the validation and returns a result back.</p>
<pre><code class="language-haskell">validateName : String -&gt; Result String (String -&gt; a) -&gt; Result String a
validateName name =
    Result.andThen
        (\constructor -&gt;
            if String.isEmpty name then
                Err &quot;Invalid name&quot;

            else
                Ok (constructor name)
        )
</code></pre>
<p>Complete example <a href="https://ellie-app.com/9SZTHJqB5r2a1">https://ellie-app.com/9SZTHJqB5r2a1</a></p>
<h2><a class="header" href="#caveat" id="caveat">Caveat</a></h2>
<p>When using this pattern we have to be careful with the order of functions in the pipeline. It is easy to make a mistake when the end type has many attribute of the same type.</p>
<pre><code class="language-haskell">type alias User =
	{ name: String
	, email: String
	}
</code></pre>
<p>With this type, we can mix up the order of name validation and email validation e.g.</p>
<pre><code class="language-haskell">    Ok User
        |&gt; validateEmail user.email
        |&gt; validateName user.name
</code></pre>
<p>This will work, but it will give us a <code>User</code> with the attributes mixed up:</p>
<pre><code class="language-haskell">{ name = &quot;sam@sample.com&quot;
, email = &quot;Sam&quot;
}
</code></pre>
<hr />
<p>Some example packages using this:</p>
<ul>
<li>Json decoding <a href="https://package.elm-lang.org/packages/elm/json/latest/Json.Decode">https://package.elm-lang.org/packages/elm/json/latest/Json.Decode</a></li>
<li>Validation <a href="https://package.elm-lang.org/packages/stoeffel/elm-verify/latest/">https://package.elm-lang.org/packages/stoeffel/elm-verify/latest/</a></li>
<li>More validation <a href="https://package.elm-lang.org/packages/gege251/elm-validator-pipeline/">https://package.elm-lang.org/packages/gege251/elm-validator-pipeline/</a></li>
</ul>
<h1><a class="header" href="#opaque-types" id="opaque-types">Opaque types</a></h1>
<p>Opaque types are types that cannot be created outside of a specific module. For example:</p>
<pre><code class="language-haskell">module Lib

exposing (Config)

type Config = Config { size: Int, style: Style }
</code></pre>
<p>This module expose the <code>Config</code> type but not the constructor. An external module can't construct or modify a <code>Config</code> type.</p>
<p>Opaque types are useful for:</p>
<ul>
<li>Enforcing invariants: Only the relevant module can change the data and ensure it follows some invariants.</li>
<li>Hiding the implementation to external modules. This is quite useful for building packages. Using opaque types makes it easier to change the implementation without breaking the code using it.</li>
</ul>
<h2><a class="header" href="#anti-pattern-3" id="anti-pattern-3">Anti-pattern</a></h2>
<pre><code class="language-haskell">module Lib

exposing (Config)

type alias Config = { size: Int, style: Style }
</code></pre>
<p>This module exposes <code>Config</code> transparently. Any changes we want to make will require changes in the module using this. In the case of a package, if we remove or change a type in <code>Config</code> we will have to publish a major version of this package.</p>
<h2><a class="header" href="#pattern-7" id="pattern-7">Pattern</a></h2>
<pre><code class="language-haskell">module Lib

exposing (Config, newConfig, withSize)

type Config = Config { size: Int, style: Style }

newConfig : Config
newConfig =
	Config { size: 1, style : Big }

withSize : Int -&gt; Config -&gt; Config
</code></pre>
<p>This module allows an application to create a <code>Config</code> and update it. But if we decide to change how we store the <code>Config</code> we can do so without any breaking changes for the caller module using this.</p>
<p>The next page explains using opaque types for enforcing invariants.</p>
<h1><a class="header" href="#opaque-types-for-enforcing-invariants" id="opaque-types-for-enforcing-invariants">Opaque types for enforcing invariants</a></h1>
<p>Some times we want our data to always follow certain rules. E.g. We would like a list that is always sorted.</p>
<p>Using opaque types we can create a module that enforces this invariant.</p>
<pre><code class="language-haskell">module SortedList exposing (SortedList, new, add)

type SortedList a =
	SortedList (List a)

new : SortedList a
new =
	SortedList []

add : (a -&gt; a -&gt; Order) -&gt; a -&gt; SortedList a -&gt; SortedList a
</code></pre>
<p>Only this module can create a <code>SortedList</code> as we don't expose the constructor.</p>
<p>Also, only this module can add an item to the list. By doing this we can enforce that the list is always sorted. External modules cannot change this data, so they are unable to break the sort invariant.</p>
<h1><a class="header" href="#process-flow-using-phantom-types" id="process-flow-using-phantom-types">Process flow using phantom types</a></h1>
<p>Sometimes we want to create a process that needs to follow different paths until it reaches an end point. Like a finite state machine.</p>
<p>For example we want an order form where you can change the total or the quantity. When you change any of these two, the other value needs to change automatically.</p>
<p><img src="advanced/flow-phantom-types/form.png" alt="Form" /></p>
<ul>
<li>When the user updates the total we want to update the quantity</li>
<li>When the user updates the quantity we want to update the total</li>
</ul>
<p>These two flows can be illustrated with a state machine:</p>
<p><img src="advanced/flow-phantom-types/state-machine.png" alt="State machine" /></p>
<p>This is a simple example to illustrate this pattern. This particular example can be done with less ceremony, but in more complex scenarios this pattern is really valuable.</p>
<p>We want to design our code in way that:</p>
<ul>
<li>Enforces running through the process steps in the correct order (depending on the user intention)</li>
<li>Doesn't let us forget a step</li>
</ul>
<h2><a class="header" href="#anti-pattern-4" id="anti-pattern-4">Anti-pattern</a></h2>
<p>One possible way of doing this is by creating intermediate types for our process:</p>
<pre><code class="language-elm">
type alias InvalidOrder =
	{ quantity : Maybe Int, total : Maybe Int }

type alias OrderWithQuantity =
	{ quantity : Int, total: Maybe Int }

type alias OrderWithTotal =
	{ quantity : Maybe Int, total: Int }

type alias Order =
	{ quantity : Int, total : Int }

setTotal : Int -&gt; InvalidOrder -&gt; OrderWithTotal

adjustQuantityFromTotal : OrderWithTotal -&gt; Order

setQuantity : Int -&gt; InvalidOrder -&gt; OrderWithQuantity

adjustTotalFromQuantity : OrderWithQuantity -&gt; Order
</code></pre>
<p>Although this is not too bad here, if we were to have more paths and attributes the multiplication of intermediate types would get out of hand really quickly.</p>
<h2><a class="header" href="#pattern-8" id="pattern-8">Pattern</a></h2>
<p><strong>Phantom types</strong> allow us to deal with this in an elegant way.</p>
<h3><a class="header" href="#state-machine-states" id="state-machine-states">State machine states</a></h3>
<p>First we need some types to define the state machine states:</p>
<pre><code class="language-haskell">type Step step
    = Step Order


type Start
    = Start


type OrderWithTotal
    = OrderWithTotal


type OrderWithQuantity
    = OrderWithQuantity


type Done
    = Done
</code></pre>
<p>The <code>phantom type</code> here is in <code>Step</code>. Note how it defines a <code>step</code> type variable that is not used in the constructor.</p>
<h3><a class="header" href="#transitions" id="transitions">Transitions</a></h3>
<p>Then we can create transition functions that use the phantom type to restrict what they take and return.</p>
<p>For example:</p>
<pre><code>adjustQuantityFromTotal : Step OrderWithTotal -&gt; Step Done
</code></pre>
<p>This function can only take a <code>Step</code> that is in the <code>OrderWithTotal</code> state. And returns a <code>Step</code> in <code>Done</code> state.</p>
<p>For our order state machine we need these functions:</p>
<pre><code class="language-elm">setTotal : Int -&gt; Step Start -&gt; Step OrderWithTotal

adjustQuantityFromTotal : Step OrderWithTotal -&gt; Step Done

setQuantity : Int -&gt; Step Start -&gt; Step OrderWithQuantity

adjustTotalFromQuantity : Step OrderWithQuantity -&gt; Step Done

done : Step Done -&gt; Order
</code></pre>
<p><img src="advanced/flow-phantom-types/state-machine.png" alt="State machine" /></p>
<p>These functions are state machine transitions. They only allow moving from specific states to other specific states.</p>
<h3><a class="header" href="#flows" id="flows">Flows</a></h3>
<p>And finally we can build the valid flows using these functions:</p>
<pre><code class="language-elm">flowPrioritizingTotal total order =
    Step order
        |&gt; setTotal total
        |&gt; adjustQuantityFromTotal
        |&gt; done


flowPrioritizingQuantity quantity order =
    Step order
        |&gt; setQuantity quantity
        |&gt; adjustTotalFromQuantity
        |&gt; done
</code></pre>
<p>In this way we can enforce specific processes without creating a myriad of intermediate types.</p>
<p>See a working example here <a href="https://ellie-app.com/9SywZggd5m5a1">https://ellie-app.com/9SywZggd5m5a1</a></p>
<h1><a class="header" href="#the-nested-elm-architecture" id="the-nested-elm-architecture">The nested Elm architecture</a></h1>
<p>When an application starts growing large we might want to break the application messages into discrete parts. For example:</p>
<ul>
<li>Root Application
<ul>
<li>Page 1</li>
<li>Page 2</li>
<li>...</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#pattern-9" id="pattern-9">Pattern</a></h2>
<p>The nested Elm architecture is a way of achieving this.</p>
<pre><code class="language-haskell">module Main exposing (main)

import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)
import Sub


type alias Model =
    { count : Int
    , subModel : Sub.Model
    }


newModel : Model
newModel =
    { count = 0
    , subModel = Sub.newModel
    }


type Msg
    = Increment
    | Sub Sub.Msg


update : Msg -&gt; Model -&gt; Model
update msg model =
    case msg of
        Increment -&gt;
            { model | count = model.count + 1 }

        Sub subMessage -&gt;
            { model
                | subModel =
                    Sub.update subMessage model.subModel
            }


view : Model -&gt; Html Msg
view model =
    div []
        [ div [] [ text &lt;| String.fromInt model.count ]
        , button [ onClick Increment ] [ text &quot;+1&quot; ]
        , Sub.view model.subModel |&gt; Html.map Sub
        ]


main : Program () Model Msg
main =
    Browser.sandbox
        { init = newModel
        , view = view
        , update = update
        }
</code></pre>
<p>Note the <code>Sub.view model.subModel |&gt; Html.map Sub</code> in <code>view</code>.</p>
<p>Sub.elm :</p>
<pre><code class="language-haskell">
module Sub exposing (..)

...

type alias Model =
    { count : Int }


newModel : Model
newModel =
    { count = 0
    }


type Msg
    = Increment


update : Msg -&gt; Model -&gt; Model
update msg model =
    case msg of
        Increment -&gt;
            { model | count = model.count + 1 }


view : Model -&gt; Html Msg
view model =
    div []
        [ div [] [ text &lt;| String.fromInt model.count ]
        , button [ onClick Increment ] [ text &quot;+1&quot; ]
        ]
</code></pre>
<p>This pattern comes with its own set of challenges like:</p>
<ul>
<li>Added boilerplate</li>
<li>It is not simple for the child module to communicate with the parent module.</li>
</ul>
<p>So this pattern is best used sparingly.</p>
<h1><a class="header" href="#global-actions" id="global-actions">Global actions</a></h1>
<p>If we use the nested TEA for our application, we will most likely need a way for the nested modules to communicate with the top levels. For example:</p>
<ul>
<li>Open a notification</li>
<li>Sign out the user</li>
<li>Return a value to the top level</li>
</ul>
<p>There are many way of achieving this. One possible way is to have a module with global actions e.g.</p>
<pre><code class="language-haskell">module Actions exposing(..)

type Action
	= OpenSuccessNotification ...
	| OpenFailureNotifiation ...
	| ...
</code></pre>
<p>The all your nested module will return three elements on <code>update</code>. The third one being a list of actions to execute:</p>
<pre><code class="language-haskell">update : Msg -&gt; Model -&gt; (Model, Cmd Msg, List Action)
</code></pre>
<p>Any nested module in the chain could add an action to the list.</p>
<p>Finally your root <code>update</code> will need to map through the list and process the actions.</p>
<hr />
<ul>
<li>A nice pattern for adding actions is to mimic <code>Cmd.batch</code>. E.g. <code>Actions.batch</code>.</li>
<li>We might need to send a message back to the module that returned the action. E.g. Open a dialog with selections. In this case our actions might need a message associated with them e.g. <code>Action Msg</code>. We will need a <code>Actions.map</code> to just like <code>Html.map</code>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
