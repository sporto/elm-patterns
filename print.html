<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Elm Patterns</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Elm patterns</a></li><li class="chapter-item expanded "><strong aria-hidden="true">2.</strong> Basic patterns</li><li><ol class="section"><li class="chapter-item expanded "><a href="basic/type-blindness.html"><strong aria-hidden="true">2.1.</strong> Type blindness</a></li><li class="chapter-item expanded "><a href="basic/minimize-boolean.html"><strong aria-hidden="true">2.2.</strong> Minimize boolean usage</a></li><li class="chapter-item expanded "><a href="basic/named-arguments.html"><strong aria-hidden="true">2.3.</strong> Named arguments</a></li><li class="chapter-item expanded "><a href="basic/wrap-early.html"><strong aria-hidden="true">2.4.</strong> Wrap early, unwrap late</a></li><li class="chapter-item expanded "><a href="basic/unwrap-maybe-early.html"><strong aria-hidden="true">2.5.</strong> Unwrap maybe early</a></li><li class="chapter-item expanded "><a href="basic/impossible-states.html"><strong aria-hidden="true">2.6.</strong> Make impossible states impossible</a></li><li class="chapter-item expanded "><a href="basic/parse-dont-validate.html"><strong aria-hidden="true">2.7.</strong> Parse don't validate</a></li><li class="chapter-item expanded "><a href="basic/builder-pattern.html"><strong aria-hidden="true">2.8.</strong> The builder pattern</a></li><li class="chapter-item expanded "><a href="basic/arguments-list.html"><strong aria-hidden="true">2.9.</strong> Arguments list</a></li><li class="chapter-item expanded "><a href="basic/type-iterator.html"><strong aria-hidden="true">2.10.</strong> Type iterator</a></li><li class="chapter-item expanded "><a href="basic/conditional-rendering.html"><strong aria-hidden="true">2.11.</strong> Conditional rendering</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">3.</strong> Advanced patterns</li><li><ol class="section"><li class="chapter-item expanded "><a href="advanced/railway.html"><strong aria-hidden="true">3.1.</strong> Railway</a></li><li class="chapter-item expanded "><a href="advanced/pipeline-builder.html"><strong aria-hidden="true">3.2.</strong> Pipeline builder</a></li><li class="chapter-item expanded "><a href="advanced/opaque-types.html"><strong aria-hidden="true">3.3.</strong> Opaque types</a></li><li class="chapter-item expanded "><a href="advanced/opaque-types-invariants.html"><strong aria-hidden="true">3.4.</strong> Opaque types for enforcing invariants</a></li><li class="chapter-item expanded "><a href="advanced/combinators.html"><strong aria-hidden="true">3.5.</strong> Combinators</a></li><li class="chapter-item expanded "><a href="advanced/phantom-types.html"><strong aria-hidden="true">3.6.</strong> Phantom types</a></li><li class="chapter-item expanded "><a href="advanced/flow-phantom-types.html"><strong aria-hidden="true">3.7.</strong> Process flow using phantom types</a></li></ol></li><li class="chapter-item expanded "><strong aria-hidden="true">4.</strong> Architecture</li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/reusable-views.html"><strong aria-hidden="true">4.1.</strong> Reusable views</a></li><li class="chapter-item expanded "><a href="architecture/nested-tea.html"><strong aria-hidden="true">4.2.</strong> Nested TEA</a></li><li class="chapter-item expanded "><a href="architecture/child-outcome.html"><strong aria-hidden="true">4.3.</strong> Child outcome</a></li><li class="chapter-item expanded "><a href="architecture/translator.html"><strong aria-hidden="true">4.4.</strong> Translator</a></li><li class="chapter-item expanded "><a href="architecture/global-actions.html"><strong aria-hidden="true">4.5.</strong> Global actions</a></li><li class="chapter-item expanded "><a href="architecture/effects.html"><strong aria-hidden="true">4.6.</strong> The effects pattern</a></li><li class="chapter-item expanded "><a href="architecture/update-return-pipeline.html"><strong aria-hidden="true">4.7.</strong> Update return pipeline</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Elm Patterns</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/sporto/elm-patterns" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#elm-patterns" id="elm-patterns">Elm patterns</a></h1>
<p>A collection of common patterns for Elm.</p>
<h1><a class="header" href="#type-blindness" id="type-blindness">Type blindness</a></h1>
<p>Type blindness is when you have several values of the same type that could get mixed up.</p>
<p><strong>Example 1</strong></p>
<pre><code class="language-haskell">type alias User =
  { firstName: String, lastName: String }
</code></pre>
<p>Both attributes are <code>String</code>. It is easy to mix them up when receiving external information. </p>
<p><strong>Example 2</strong></p>
<pre><code class="language-haskell">priceInDollars : Float
priceInDollars = 2.0

priceInEuros : Float
priceInEuros = 1
</code></pre>
<p>Both values are <code>Float</code>. There is nothing preventing us from doing a non sensical operation like <code>priceInDollars + priceInEuros</code>.</p>
<h2><a class="header" href="#pattern" id="pattern">Pattern</a></h2>
<p>In this case consider wrapping values in a unique type.</p>
<pre><code class="language-haskell">type Dollar = Dollar Float

priceInDollars : Dollar
priceInDollar =
  Dollar 2.0
</code></pre>
<p>You will need to unwrap values later, which can get tedious, so use this when there is a good potential of mixing up values. </p>
<h1><a class="header" href="#minimize-boolean-usage" id="minimize-boolean-usage">Minimize boolean usage</a></h1>
<p>Boolean ambiguity can lead to loss of intent and loss of information in our code, resulting in ambiguous logic. To avoid this issue, we should prefer self-documenting alternatives whenever the intention is unclear.</p>
<p>This pattern is inspired by <a href="https://github.com/jfairbank">Jeremy Fairbank</a>'s <a href="https://www.youtube.com/watch?v=6TDKHGtAxeg">&quot;Solving the Boolean Identity Crisis&quot;</a> talk and <a href="https://programming-elm.com/blog/2019-05-20-solving-the-boolean-identity-crisis-part-1/">series of articles</a>, where he explains the rationale and the pattern in great details, if you want to delve deeper.</p>
<h2><a class="header" href="#boolean-ambiguity" id="boolean-ambiguity">Boolean Ambiguity</a></h2>
<p>Boolean arguments can make code confusing and harder to maintain by hiding the intent of code.</p>
<h3><a class="header" href="#anti-pattern-1" id="anti-pattern-1">Anti-Pattern 1</a></h3>
<p>What is the significance of the <code>True</code> value here without looking up the definition of <code>bookFlight</code>?</p>
<pre><code class="language-haskell">bookFlight &quot;ELM&quot; True
</code></pre>
<h3><a class="header" href="#pattern-1" id="pattern-1">Pattern 1</a></h3>
<p>We can clean up the <code>bookFlight</code> function by replacing the boolean arguments with a <code>Custom Type</code>:</p>
<pre><code class="language-haskell">type CustomerStatus
    = Premium
    | Regular
    | Economy
</code></pre>
<p>Now calls to <code>bookFlight</code> declare the intent of code because we pass in the <code>CustomerStatus</code> directly:</p>
<pre><code class="language-haskell">bookFlight &quot;ELM&quot; Premium
</code></pre>
<h2><a class="header" href="#boolean-blindness" id="boolean-blindness">Boolean Blindness</a></h2>
<p>Returning <code>Bool</code> from a function can lead to boolean blindness. This happens because we get a value that the type system cannot use for enforcing further logic in the program.</p>
<h3><a class="header" href="#anti-pattern-2" id="anti-pattern-2">Anti-Pattern 2</a></h3>
<p>For example:</p>
<pre><code class="language-haskell">time =
    if isValid formData then
        submitForm formData

    else
        showErrors formData
</code></pre>
<p>In this snippet <code>isValid</code> only returns a <code>Bool</code>. We can call <code>submitForm</code> with the original <code>formData</code>. The compiler wouldn't complain if we swap the if-else branches.</p>
<h3><a class="header" href="#pattern-2" id="pattern-2">Pattern 2</a></h3>
<p>Replace boolean return values with custom types to eliminate boolean blindness and leverage the compiler for safer code. In this example we do it with a <code>Result Error Type</code>:</p>
<pre><code class="language-haskell">time =
    case isValid formData of
        Ok validFormData -&gt;
            submitForm validFormData

        Err errors -&gt;
            showErrors errors
</code></pre>
<p>In this case <code>submitForm</code> is a function that can only be called with valid form data.</p>
<h1><a class="header" href="#named-arguments" id="named-arguments">Named arguments</a></h1>
<p>There are times when the order of arguments for a functions can be ambiguous. For example:</p>
<pre><code class="language-haskell">isBefore : Date -&gt; Date -&gt; Bool
</code></pre>
<p>What is the subject date here and the comparison date? </p>
<p>As we usually put the data at the end (for pipelines) we might think that the subject is the second date, but maybe is not. This is vague and error prone.</p>
<p>In this cases is better if we ask for a record as argument:</p>
<pre><code class="language-haskell">isBefore : { subject: Date, comparedTo: Date } -&gt; Bool
</code></pre>
<p>This might not be pipeline friendly, but it is a lot more precise and hard to get wrong.</p>
<h1><a class="header" href="#wrap-early-unwrap-late" id="wrap-early-unwrap-late">Wrap early, unwrap late</a></h1>
<p>To avoid type blindness, you probably want to wrap your values in unique types.</p>
<p>When you do this it is a good idea to wrap your types as early as possible. E.g. when decoding values from external sources.</p>
<p>Then try to unwrap as late as possible.</p>
<h2><a class="header" href="#example-anti-patterns" id="example-anti-patterns">Example anti-patterns</a></h2>
<pre><code class="language-haskell">displayPriceInDollars : Float -&gt; String
displayPriceInDollars price =
    &quot;USD$&quot; ++ String.fromFloat price
</code></pre>
<p>There is nothing stopping us from passing something that is not dollars here (e.g. we might use Euros).</p>
<pre><code class="language-haskell">calculateTotalPrice: List Float -&gt; Float
</code></pre>
<p>We could send a list of mixed currencies e.g. dollars and euros.</p>
<h2><a class="header" href="#pattern-1" id="pattern-1">Pattern</a></h2>
<pre><code class="language-haskell">type Dollar = Dollar Float

displayPriceInDollars : Dollar -&gt; String
displayPriceInDollars (Dollar price) =
    &quot;USD$&quot; ++ String.fromFloat price
</code></pre>
<p>This enforces that we use the <code>Dollar</code> type as much as possible.</p>
<h1><a class="header" href="#unwrap-maybe-and-result-early" id="unwrap-maybe-and-result-early">Unwrap Maybe and Result early</a></h1>
<p>If you have a <code>Maybe</code>, <code>Result</code> or <code>RemoteData</code> it is often a good idea to try to unwrap those as early as possible.</p>
<h2><a class="header" href="#anti-pattern" id="anti-pattern">Anti-pattern</a></h2>
<pre><code class="language-haskell">userCard : Maybe User -&gt; Html Msg
userCard maybeUser =
   div []
        [ userInfo maybeUser
        , userActivity maybeUser
        ]
</code></pre>
<p>In here both <code>userInfo</code> and <code>userActivy</code> get a <code>Maybe User</code>. Meaning that will need to unwrap this value several times in your views.</p>
<h2><a class="header" href="#pattern-2" id="pattern-2">Pattern</a></h2>
<pre><code class="language-haskell">userCard maybeUser =
    case maybeUser of
        Nothing -&gt;
            div [] [ ... ]

        Just user -&gt;
            div []
                [ userInfo user
                , userActivity user
                ]
</code></pre>
<p>Here the sub views take a <code>User</code>, this makes most of your views easier to write and test. </p>
<h1><a class="header" href="#make-impossible-states-impossible" id="make-impossible-states-impossible">Make impossible states impossible</a></h1>
<p>Elm has a great and expressible type system. This type system allows us to avoid having impossible states in our application.</p>
<h2><a class="header" href="#anti-pattern-1" id="anti-pattern-1">Anti-pattern</a></h2>
<p>A common pattern is to have a boolean attribute to show a loading spinner while data is loading. e.g.</p>
<pre><code class="language-haskell">type alias Model =
    { isLoading: Bool
    , data: Maybe Data
    }
</code></pre>
<p>But in this type it is possible to have something like <code>isLoading = false</code> and <code>data = Nothing</code>. What is the meaning of this? This is probably an impossible state that should never happen.</p>
<h2><a class="header" href="#pattern-3" id="pattern-3">Pattern</a></h2>
<p>With Elm you can represent your types in ways that don't allow for impossible states. e.g</p>
<pre><code class="language-haskell">type RemoteData
    = Loading
    | Loaded Data

type alias Model =
    { data : RemoteData }
</code></pre>
<p><a href="https://www.youtube.com/watch?v=IcgmSRJHu_8">Here is an excellent talk about this</a>.</p>
<h1><a class="header" href="#parse-dont-validate" id="parse-dont-validate">Parse don't validate</a></h1>
<p>When we have external data (e.g. user input or remote data) it is a common pattern to validate this data before using it.</p>
<h2><a class="header" href="#anti-pattern-2" id="anti-pattern-2">Anti-pattern</a></h2>
<p>A common approach is to ask if the data is valid and then use it e.g.</p>
<pre><code class="language-haskell">type alias UserInput =
    { name: Maybe String
    , age: Maybe Int
    }

isValidUser : UserInput -&gt; Bool
</code></pre>
<p>The problem with this approach is that after doing this you still have a <code>UserInput</code> with can still hold invalid values.</p>
<h2><a class="header" href="#pattern-4" id="pattern-4">Pattern</a></h2>
<p>A better approach is to &quot;parse&quot; your input and return a known valid type. e.g.</p>
<pre><code class="language-haskell"> type alias UserInput =
    { name: Maybe String
    , age: Maybe Int
    }

type alias ValidUser =
    { name: String
    , age: Int
    }

validateUser : UserInput -&gt; Result String ValidUser
</code></pre>
<p>In this way you ensure that you have a valid type to work with later on. Some examples where this is useful:</p>
<ul>
<li>Validating user input</li>
<li>Parsing JSON from external sources</li>
</ul>
<h1><a class="header" href="#the-builder-pattern" id="the-builder-pattern">The builder pattern</a></h1>
<p>When we need to pass many arguments to a function we might have something like</p>
<pre><code class="language-haskell">module Button exposing (..)

type alias Args =
    { isEnabled : Bool
    , label : String
    , hexColor : String
    , ...
    }

btn: Args -&gt; Html msg
</code></pre>
<p>In the caller module:</p>
<pre><code class="language-haskell">import Button

Button.btn { isEnabled = True, label = &quot;Click me&quot;, ....}
</code></pre>
<p>The problem with this is that each time we add an argument to <code>Args</code> we need to change every single place where we call this function.</p>
<h2><a class="header" href="#pattern-5" id="pattern-5">Pattern</a></h2>
<p>With builder pattern we build the arguments with the minimum necessary information, then modify the arguments if we need to.</p>
<pre><code class="language-haskell">module Button exposing (..)

newArgs: String -&gt; Args
newArgs label =
    { isEnabled = True
    , label = label
    , hexColor: &quot;#ABC&quot;
    , ...
    }

withIsEnabled : Bool -&gt; Args -&gt; Args
withIsEnabled isEnabled args =
    { args | isEnabled = isEnabled }

btn: Args -&gt; Html msg
</code></pre>
<p>This modules exposes a function to create the initial arguments and a series of function to modify the arguments (commonly using <code>with</code> as prefix).</p>
<p>Then the caller module uses this:</p>
<pre><code class="language-haskell">import Button

aButton =
    Button.newArgs &quot;Click me&quot;
        |&gt; Button.withIsEnabled False
        |&gt; Button.withHexColor &quot;#123&quot;
        |&gt; Button.btn
</code></pre>
<p>The advantage of this is that adding new arguments to <code>Args</code> doesn't require us to change every caller.</p>
<h2><a class="header" href="#as-test-factories" id="as-test-factories">As test factories</a></h2>
<p>This pattern is also very useful for tests. Similar to test factories in many languages. For example if we were testing a <code>User</code>, we could start with a basic user and then use the builder pattern to modify attributes for different tests.</p>
<h1><a class="header" href="#arguments-list" id="arguments-list">Arguments list</a></h1>
<p>The builder patterns gives us to build configuration. We could also use plain lists for this:</p>
<pre><code class="language-haskell">view =
  shape
    [ scale 0.5 0.5 0.5
    , position 0 -6 -13
    , rotation -90 0 0
    ]
</code></pre>
<p>Our module exposes a series of functions that return a common type e.g.</p>
<pre><code class="language-haskell">scale : Float -&gt; Float -&gt; Float -&gt; Attribute

rotation : Int -&gt; Int -&gt; Int -&gt; Attribute
</code></pre>
<p>Using that we can build a <code>List Attribute</code> and pass it to a function as configuration.</p>
<p>This is the pattern used in elm/html, elm/svg, elm-css, elm-ui.</p>
<ul>
<li>This pattern is best used with Opaque types. As we don't usually want the caller to be able access the returned type (e.g. <code>Attribute</code>).</li>
<li>This pattern is best when all arguments are optional as we cannot avoid having the caller pass an empty list.</li>
</ul>
<h1><a class="header" href="#type-iterator" id="type-iterator">Type iterator</a></h1>
<p>When we have a list of all the variants in our custom type, sometimes that list can get out-of-sync when we add a new variant.</p>
<pre><code class="language-haskell">module Color exposing (Color(..), all)

type Color
    = Red
    | Yellow
    | Green
    | Blue -- Recently added

all : List Color
all =
    [ Red, Yellow, Green ]
    -- Forgot to add Blue here
</code></pre>
<p>It would be nice if the compiler could remind us.
Especially so if there are many variants.</p>
<p>There are at least two solutions to this.</p>
<p>The first one is using an <a href="https://package.elm-lang.org/packages/jfmengels/elm-review/latest/"><code>elm-review</code></a> rule <a href="https://package.elm-lang.org/packages/Arkham/elm-review-no-missing-type-constructor/latest/"><code>NoMissingTypeConstructor</code></a> that automatically checks lists of custom type constructors named <code>all*</code> and warns when they get out of sync.</p>
<p>The second one is to get the compiler to remind us of a missing variant by building our list with a <code>case</code> statement.</p>
<pre><code class="language-haskell">module Color exposing (Color(..), all)

type Color
    = Red
    | Yellow
    | Green
    | Blue -- Recently added

all : List Color
all =
    next [] |&gt; List.reverse

next : List Color -&gt; List Color
next list =
    case List.head list of
        Nothing -&gt;
            Red :: list |&gt; next

        Just Red -&gt;
            Yellow :: list |&gt; next

        Just Yellow -&gt;
            Green :: list |&gt; next

        Just Green -&gt;
            list -- return the list as is on the final variant

        -- Blue is still missing, but now, the compiler will complain
        -- until we add it here

</code></pre>
<p>Important: We should never use wildcard matching <code>_</code> in the <code>next</code> function.
It would prevent the compiler from detecting new variants.</p>
<h1><a class="header" href="#conditional-rendering" id="conditional-rendering">Conditional rendering</a></h1>
<p>Many time we want to conditionally render an element. For example, sometimes we want to render a banner, sometimes we don't. Here are some common patterns for this:</p>
<h2><a class="header" href="#using-maybe" id="using-maybe">Using Maybe</a></h2>
<p>We can write our HTML like:</p>
<pre><code class="language-haskell">[ Just headerElement
, maybeBanner showBanner
, Just content
, Just footerElement
] |&gt; List.filterMap identity

maybeBanner showBanner =
  if showBanner then
     Just bannerElement
  else
    Nothing
</code></pre>
<p>In this pattern we create a list of Maybes, and then use <code>List.filterMap identity</code> to remove the  Nothings.</p>
<h2><a class="header" href="#using-a-no-op" id="using-a-no-op">Using a no-op</a></h2>
<p>We can also achieve this using:</p>
<pre><code class="language-haskell">[ headerElement
, maybeBanner showBanner
, content
, footerElement
]

maybeBanner showBanner =
  if showBanner then
     bannerElement
  else
    text &quot;&quot;
</code></pre>
<p>In this case <code>text &quot;&quot;</code> is a no-op (No operation). So nothing gets rendered.
To achieve the same for attributes we can use <code>class &quot;&quot;</code>.</p>
<h2><a class="header" href="#using-list-concatenation" id="using-list-concatenation">Using list concatenation</a></h2>
<p>And we could also write our HTML like:</p>
<pre><code class="language-haskell">( [ headerElement ]
++ maybeBanner showBanner
++ [ content, footerElement ]
)

maybeBanner showBanner =
  if showBanner then
    [ bannerElement ]
  else
    []
</code></pre>
<p>In this case we use list concatenation to assemble the HTML. When we don't need to render the banner we can return an empty list.</p>
<h1><a class="header" href="#the-railway-pattern" id="the-railway-pattern">The railway pattern</a></h1>
<p>The railway pattern is a way of chaining operations where each might fail.
It is called railway because there are two tracks in this pattern.</p>
<ul>
<li>The first track is the happy path</li>
<li>The second track is the error track</li>
</ul>
<p>If any of the chained functions fails we move to the error track. From there we get an error at the end of the railway.</p>
<p>For example, let say we want to:</p>
<ul>
<li>Parse some external data</li>
<li>Validate the parsed data</li>
<li>Transform the data into something else</li>
</ul>
<pre><code class="language-haskell">parseData : String -&gt; Result String ParsedData

validateData : ParsedData -&gt; Result String ValidData

transformData : ValidData -&gt; Result String TransformedData
</code></pre>
<h2><a class="header" href="#pattern-6" id="pattern-6">Pattern</a></h2>
<p>In Elm this is commonly done using <code>Maybe.andThen</code> and <code>Result.andThen</code>. These function will run the next function in the chain if the previous function was successful, otherwise they will propagate the error.</p>
<pre><code class="language-haskell">process : String -&gt; Result String TransformedData
process data =
	parseData data
		|&gt; Result.andThen validateData
		|&gt; Result.andThen transformData
</code></pre>
<p><a href="https://fsharpforfunandprofit.com/rop/">Here is an excellent post about this with a lot more details</a>.</p>
<h2><a class="header" href="#variant" id="variant">Variant</a></h2>
<p>A variant of this is where the second track doesn't represent an error, but rather an early exit.</p>
<p>E.g. This process finds recommendations for a user. Each function in the chain can add to the recommendations or choose to exit the process.</p>
<pre><code class="language-haskell">type Process
	= Continue Recommendation
	| Exit Recommendation

andThen : (Recommendation -&gt; Process) -&gt; Process -&gt; Process
andThen callback process =
	case process of
		Continue document -&gt; callback document
		Exit document -&gt; Exit document

findRecommendations user =
	Continue emptyRecommendation
		|&gt; andThen (findMusic user)
		|&gt; andThen (findBooks user)
		|&gt; andThen (findMovies user)
		|&gt; andThen (findGames user)

findMusic : User -&gt; Recommendation -&gt; Process

...
</code></pre>
<p><code>andThen</code> is a function that mirrors <code>Result.andThen</code> but specific for <code>Process</code>.</p>
<h1><a class="header" href="#pipeline-builder" id="pipeline-builder">Pipeline builder</a></h1>
<p>This is a common pattern used for decoders and validation. This pattern is used to build a function for processing some data using a series of piped functions.</p>
<pre><code class="language-haskell">type alias User =
	{ name: String
	, age: Int
	}

validateUser : User -&gt; Result String User
validateUser user =
    Ok User
        |&gt; validateName user.name
        |&gt; validateAge user.age
</code></pre>
<p>This builds a function <code>validateUser</code> that will take a user and validate it. This <code>validateUser</code> function works like the railway pattern. We might get an <code>Ok User</code> at the end or an error <code>Err String</code>.</p>
<p>This pattern relies on the fact that a type alias in Elm can be used as a function. e.g. <code>User</code> is a function like:</p>
<pre><code class="language-haskell">String -&gt; Int -&gt; User
</code></pre>
<p>We start by putting the function (<code>User</code>) into a Result.</p>
<p>Then each function in the chain takes an attribute and the previous result, does the validation and returns a result back.</p>
<pre><code class="language-haskell">validateName : String -&gt; Result String (String -&gt; a) -&gt; Result String a
validateName name =
    Result.andThen
        (\constructor -&gt;
            if String.isEmpty name then
                Err &quot;Invalid name&quot;

            else
                Ok (constructor name)
        )
</code></pre>
<p>Complete example <a href="https://ellie-app.com/9SZTHJqB5r2a1">https://ellie-app.com/9SZTHJqB5r2a1</a></p>
<h2><a class="header" href="#caveat" id="caveat">Caveat</a></h2>
<p>When using this pattern we have to be careful with the order of functions in the pipeline. It is easy to make a mistake when the end type has many attribute of the same type.</p>
<pre><code class="language-haskell">type alias User =
	{ name: String
	, email: String
	}
</code></pre>
<p>With this type, we can mix up the order of name validation and email validation e.g.</p>
<pre><code class="language-haskell">    Ok User
        |&gt; validateEmail user.email
        |&gt; validateName user.name
</code></pre>
<p>This will work, but it will give us a <code>User</code> with the attributes mixed up:</p>
<pre><code class="language-haskell">{ name = &quot;sam@sample.com&quot;
, email = &quot;Sam&quot;
}
</code></pre>
<hr />
<p>Some example packages using this:</p>
<ul>
<li>Json decoding <a href="https://package.elm-lang.org/packages/elm/json/latest/Json.Decode">https://package.elm-lang.org/packages/elm/json/latest/Json.Decode</a></li>
<li>Validation <a href="https://package.elm-lang.org/packages/stoeffel/elm-verify/latest/">https://package.elm-lang.org/packages/stoeffel/elm-verify/latest/</a></li>
<li>More validation <a href="https://package.elm-lang.org/packages/gege251/elm-validator-pipeline/">https://package.elm-lang.org/packages/gege251/elm-validator-pipeline/</a></li>
</ul>
<h1><a class="header" href="#opaque-types" id="opaque-types">Opaque types</a></h1>
<p>Opaque types are types that cannot be created outside of a specific module. For example:</p>
<pre><code class="language-haskell">module Lib exposing (Config)

type Config = Config { size: Int, style: Style }
</code></pre>
<p>This module expose the <code>Config</code> type but not the constructor. An external module can't construct or modify a <code>Config</code> type.</p>
<p>Opaque types are useful for:</p>
<ul>
<li>Enforcing invariants: Only the relevant module can change the data and ensure it follows some invariants.</li>
<li>Hiding the implementation to external modules. This is quite useful for building packages. Using opaque types makes it easier to change the implementation without breaking the code using it.</li>
</ul>
<h2><a class="header" href="#anti-pattern-3" id="anti-pattern-3">Anti-pattern</a></h2>
<pre><code class="language-haskell">module Lib exposing (Config)

type alias Config = { size: Int, style: Style }
</code></pre>
<p>This module exposes <code>Config</code> transparently. Any changes we want to make will require changes in the module using this. In the case of a package, if we remove or change a type in <code>Config</code> we will have to publish a major version of this package.</p>
<h2><a class="header" href="#pattern-7" id="pattern-7">Pattern</a></h2>
<pre><code class="language-haskell">module Lib exposing (Config, newConfig, withSize)

type Config = Config { size: Int, style: Style }

newConfig : Config
newConfig =
	Config { size: 1, style : Big }

withSize : Int -&gt; Config -&gt; Config
</code></pre>
<p>This module allows an application to create a <code>Config</code> and update it. But if we decide to change how we store the <code>Config</code> we can do so without any breaking changes for the caller module using this.</p>
<p>The next page explains using opaque types for enforcing invariants.</p>
<h1><a class="header" href="#opaque-types-for-enforcing-invariants" id="opaque-types-for-enforcing-invariants">Opaque types for enforcing invariants</a></h1>
<p>Some times we want our data to always follow certain rules. E.g. We would like a list that is always sorted.</p>
<p>Using opaque types we can create a module that enforces this invariant.</p>
<pre><code class="language-haskell">module SortedList exposing (SortedList, new, add)

type SortedList comparable =
	SortedList (List comparable)

new : SortedList comparable
new =
	SortedList []

add : comparable -&gt; SortedList comparable -&gt; SortedList comparable
</code></pre>
<p>Only this module can create a <code>SortedList</code> as we don't expose the constructor.</p>
<p>Also, only this module can add an item to the list. By doing this we can enforce that the list is always sorted. External modules cannot change this data, so they are unable to break the sort invariant.</p>
<h1><a class="header" href="#combinators" id="combinators">Combinators</a></h1>
<p>Combinators is a technique where combining several values of the same type gives us back a value of the same type.</p>
<p>For example:</p>
<pre><code class="language-haskell">and : Filter -&gt; Filter -&gt; Filter
</code></pre>
<p><code>and</code> is a function that takes two filters and combines them using an <code>AND</code> join. It gives us back another <code>Filter</code>.
Given that the return value is the same type, we can keep combining them endlessly.</p>
<p>Some examples of combinators are:</p>
<ul>
<li>Html</li>
<li>Cmd.batch</li>
<li>Parsers</li>
<li>JSON Decoder / Encoders</li>
<li>Filters e.g. (a AND (b OR c))</li>
<li>Validations</li>
</ul>
<p>Anything that resembles a tree is a good candiate for using combinators.</p>
<p>Combinators allow us to:</p>
<ul>
<li>Easily test each small part in isolation</li>
<li>Make complex systems from very small part</li>
<li>Create different combinations by cherry picking the parts we need</li>
</ul>
<h1><a class="header" href="#phantom-types" id="phantom-types">Phantom types</a></h1>
<p>Phantom types are types that have a type variable on the type that is not used constructors. E.g.</p>
<pre><code class="language-haskell">type Users a =
	Users (List User)
</code></pre>
<p>This type variable allows us to restrict what type a function can take and return. For example:</p>
<pre><code class="language-haskell">type Active
	= Active

activeUsers : List User -&gt; Users Active
activeUsers users =
	users
		|&gt; List.filter isActive
		|&gt; Users
</code></pre>
<p><code>activeUsers</code> is a function that takes all users and only returns active users.</p>
<p>Phantom types are useful for things like:</p>
<ul>
<li>Enforcing invariants in functions and views</li>
<li>Validation</li>
<li>State machines</li>
<li>Processes</li>
</ul>
<p>In the example below we could have a view that only takes active users:</p>
<pre><code class="language-haskell">usersView : Users Active -&gt; Html msg
</code></pre>
<p>The compiler will complain if we try to pass all users to this view. In this way it can be sure that we are filtering users correctly.</p>
<h1><a class="header" href="#process-flow-using-phantom-types" id="process-flow-using-phantom-types">Process flow using phantom types</a></h1>
<p>Sometimes we want to create a process that needs to follow different paths until it reaches an end point. Like a finite state machine.</p>
<p>For example we want an order form where you can change the total or the quantity. When you change any of these two, the other value needs to change automatically.</p>
<p><img src="advanced/flow-phantom-types/form.png" alt="Form" /></p>
<ul>
<li>When the user updates the total we want to update the quantity</li>
<li>When the user updates the quantity we want to update the total</li>
</ul>
<p>These two flows can be illustrated with a state machine:</p>
<p><img src="advanced/flow-phantom-types/state-machine.png" alt="State machine" /></p>
<p>This is a simple example to illustrate this pattern. This particular example can be done with less ceremony, but in more complex scenarios this pattern is really valuable.</p>
<p>We want to design our code in way that:</p>
<ul>
<li>Enforces running through the process steps in the correct order (depending on the user intention)</li>
<li>Doesn't let us forget a step</li>
</ul>
<h2><a class="header" href="#anti-pattern-4" id="anti-pattern-4">Anti-pattern</a></h2>
<p>One possible way of doing this is by creating intermediate types for our process:</p>
<pre><code class="language-haskell">
type alias InvalidOrder =
	{ quantity : Maybe Int, total : Maybe Int }

type alias OrderWithQuantity =
	{ quantity : Int, total: Maybe Int }

type alias OrderWithTotal =
	{ quantity : Maybe Int, total: Int }

type alias Order =
	{ quantity : Int, total : Int }

setTotal : Int -&gt; InvalidOrder -&gt; OrderWithTotal

adjustQuantityFromTotal : OrderWithTotal -&gt; Order

setQuantity : Int -&gt; InvalidOrder -&gt; OrderWithQuantity

adjustTotalFromQuantity : OrderWithQuantity -&gt; Order
</code></pre>
<p>Although this is not too bad here, if we were to have more paths and attributes the multiplication of intermediate types would get out of hand really quickly.</p>
<h2><a class="header" href="#pattern-8" id="pattern-8">Pattern</a></h2>
<p><strong>Phantom types</strong> allow us to deal with this in an elegant way.</p>
<h3><a class="header" href="#state-machine-states" id="state-machine-states">State machine states</a></h3>
<p>First we need some types to define the state machine states:</p>
<pre><code class="language-haskell">type Step step
    = Step Order


type Start
    = Start


type OrderWithTotal
    = OrderWithTotal


type OrderWithQuantity
    = OrderWithQuantity


type Done
    = Done
</code></pre>
<p>The <code>phantom type</code> here is in <code>Step</code>. Note how it defines a <code>step</code> type variable that is not used in the constructor.</p>
<h3><a class="header" href="#transitions" id="transitions">Transitions</a></h3>
<p>Then we can create transition functions that use the phantom type to restrict what they take and return.</p>
<p>For example:</p>
<pre><code>adjustQuantityFromTotal : Step OrderWithTotal -&gt; Step Done
</code></pre>
<p>This function can only take a <code>Step</code> that is in the <code>OrderWithTotal</code> state. And returns a <code>Step</code> in <code>Done</code> state.</p>
<p>For our order state machine we need these functions:</p>
<pre><code class="language-haskell">start : Order -&gt; Step Start

setTotal : Int -&gt; Step Start -&gt; Step OrderWithTotal

adjustQuantityFromTotal : Step OrderWithTotal -&gt; Step Done

setQuantity : Int -&gt; Step Start -&gt; Step OrderWithQuantity

adjustTotalFromQuantity : Step OrderWithQuantity -&gt; Step Done

done : Step Done -&gt; Order
</code></pre>
<p><img src="advanced/flow-phantom-types/state-machine.png" alt="State machine" /></p>
<p>These functions are state machine transitions. They only allow moving from specific states to other specific states.</p>
<h3><a class="header" href="#flows" id="flows">Flows</a></h3>
<p>And finally we can build the valid flows using these functions:</p>
<pre><code class="language-haskell">flowPrioritizingTotal total order =
    start order
        |&gt; setTotal total
        |&gt; adjustQuantityFromTotal
        |&gt; done


flowPrioritizingQuantity quantity order =
    start order
        |&gt; setQuantity quantity
        |&gt; adjustTotalFromQuantity
        |&gt; done
</code></pre>
<p>In this way we can enforce specific processes without creating a myriad of intermediate types.</p>
<p>See a working example here <a href="https://ellie-app.com/smDDnCh5C8Xa1">https://ellie-app.com/smDDnCh5C8Xa1</a></p>
<h1><a class="header" href="#reusable-views" id="reusable-views">Reusable views</a></h1>
<p>It is common to need reusable views in our applications. The most basic way in Elm is to have view functions that take message constructors as arguments.</p>
<p>For example:</p>
<pre><code class="language-haskell">type alias Args msg =
	{ currentDate: Date
	, isOpen: Bool
	, onOpen: msg
	, onClose: msg
	, onSelectDate : Date -&gt; msg
	}

calendar : Args msg -&gt; Html msg
calendar args =
</code></pre>
<p>This view is easy to integrate and reuse. However it requires the caller to keep track of the state e.g. <code>isOpen</code>.
Another limitation is that this view is incapable of producing commands.</p>
<h2><a class="header" href="#using-the-builder-pattern" id="using-the-builder-pattern">Using the builder pattern</a></h2>
<p>Reusable views like these are perfect candidates for the builder pattern:</p>
<pre><code class="language-haskell">Button.newArgs &quot;Clear selection&quot; Clear
	|&gt; Button.withIcon IconClear
	|&gt; Button.withSize Button.Wide
	|&gt; Button.view
</code></pre>
<h1><a class="header" href="#the-nested-elm-architecture" id="the-nested-elm-architecture">The nested Elm architecture</a></h1>
<p>When an application starts growing large we might want to break the application messages into discrete parts. For example:</p>
<ul>
<li>Root Application
<ul>
<li>Page 1</li>
<li>Page 2</li>
<li>...</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#pattern-9" id="pattern-9">Pattern</a></h2>
<p>The nested Elm architecture is a way of achieving this.</p>
<pre><code class="language-haskell">module Main exposing (main)

import Browser
import Html exposing (Html, button, div, text)
import Html.Events exposing (onClick)
import Sub


type alias Model =
    { count : Int
    , subModel : Sub.Model
    }


newModel : Model
newModel =
    { count = 0
    , subModel = Sub.newModel
    }


type Msg
    = Increment
    | Sub Sub.Msg


update : Msg -&gt; Model -&gt; Model
update msg model =
    case msg of
        Increment -&gt;
            { model | count = model.count + 1 }

        Sub subMessage -&gt;
            { model
                | subModel =
                    Sub.update subMessage model.subModel
            }


view : Model -&gt; Html Msg
view model =
    div []
        [ div [] [ text &lt;| String.fromInt model.count ]
        , button [ onClick Increment ] [ text &quot;+1&quot; ]
        , Sub.view model.subModel |&gt; Html.map Sub
        ]


main : Program () Model Msg
main =
    Browser.sandbox
        { init = newModel
        , view = view
        , update = update
        }
</code></pre>
<p>Note the <code>Sub.view model.subModel |&gt; Html.map Sub</code> in <code>view</code>.</p>
<p>Sub.elm :</p>
<pre><code class="language-haskell">
module Sub exposing (..)

...

type alias Model =
    { count : Int }


newModel : Model
newModel =
    { count = 0
    }


type Msg
    = Increment


update : Msg -&gt; Model -&gt; Model
update msg model =
    case msg of
        Increment -&gt;
            { model | count = model.count + 1 }


view : Model -&gt; Html Msg
view model =
    div []
        [ div [] [ text &lt;| String.fromInt model.count ]
        , button [ onClick Increment ] [ text &quot;+1&quot; ]
        ]
</code></pre>
<p>This pattern comes with its own set of challenges like:</p>
<ul>
<li>Added boilerplate</li>
<li>It is not simple for the child module to communicate with the parent module (see <a href="architecture/./translator.html">Translator</a>).</li>
</ul>
<p>So this pattern is best used sparingly.</p>
<h1><a class="header" href="#child-outcome" id="child-outcome">Child Outcome</a></h1>
<p>As described in <a href="architecture/./nested-tea.html">Nested TEA</a> it is sometimes useful to create a nested Elm architecture. In that case we might want to send a message from the child to the parent after an action.</p>
<p>One simple way to do this is by returning a third value in the <code>update</code> function of the child.</p>
<pre><code class="language-haskell">module Child exposing
    ( Outcome(..)
    , update
    , ...
    )

type Outcome
  = OutcomeNone
  | OutcomeDateUpdated Date

update : Msg -&gt; Model -&gt; (Model, Cmd Msg, Outcome)
</code></pre>
<p>Then the parent module can deal with that:</p>
<pre><code class="language-haskell">module Parent exposing (...)

import Child

...

update : Msg -&gt; Model -&gt; ( Model, Cmd Msg )
update msg model =
  case msg of
    ChildMsg childMsg -&gt;
      let
        (nextChildModel, childCmd, childOutcome) =
          Child.update childMsg model.childModel

      -- Do something with the childOutcome

    ...
</code></pre>
<h1><a class="header" href="#translator" id="translator">Translator</a></h1>
<p>As described in <a href="architecture/./nested-tea.html">Nested TEA</a> it is sometimes useful to create a nested Elm architecture. When making this we normally would use <code>Html.map</code> to route messages back to the nested module.</p>
<p>For example, in the parent container you would have:</p>
<pre><code class="language-haskell">module Parent exposing(..)

import Child

Child.view model.childModel |&gt; Html.map ChildMsg
</code></pre>
<p>The challenge of using <code>Html.map</code> here is that messages produced in the child module always need to route back to itself. We cannot easily produce a message in the child destined to its parent.</p>
<p>As an application grows it is common to encounter something like this, perhaps we need a UI element in the child module that needs to send the message to its parent.</p>
<h2><a class="header" href="#pattern-10" id="pattern-10">Pattern</a></h2>
<p>The solution to this is to make the child module views generic and provide a constructor for routing messages. So, instead of <code>View Msg</code> in the child module, it becomes <code>View msg</code>. Then the parent explicitly provides the constructor to route messages.</p>
<p>For example, we have a child module with a view like:</p>
<pre><code class="language-haskell">module Child exposing(..)

view: Model -&gt; Html Msg
view model =
  div []
  [ button [ onClick Clicked ] [ text model.name ]
  ]
</code></pre>
<p>We want to add another button, but this time it should send a message to its parent.</p>
<h3><a class="header" href="#first-make-the-child-module-generic" id="first-make-the-child-module-generic">First, make the child module generic</a></h3>
<pre><code class="language-haskell">module Child exposing(..)

view: Model -&gt; (Msg -&gt; msg) -&gt; Html msg
view model toSelf =
  div []
  [ button [ onClick (toSelf Clicked) ] [ text model.name ]
  ]
</code></pre>
<p>To <code>toSelf</code> is a constructor that wraps the internal message, producing a parent message. This replaces <code>Html.map</code> in the parent module and will route the message back to this module.</p>
<p>In the parent container we would use this view like:</p>
<pre><code class="language-haskell">module Parent exposing(..)

import Child

type Msg = ChildMsg Child.Msg

view model =
  ...
  Child.view model.childModel ChildMsg
</code></pre>
<h3><a class="header" href="#produce-a-parent-message" id="produce-a-parent-message">Produce a parent message</a></h3>
<p>With this setup we can produce parent messages from the child module.</p>
<pre><code class="language-haskell">module Child exposing(..)

type alias Args msg =
  { toSelf : Msg -&gt; msg
  , onSave: msg
  }

view: Model -&gt; Args msg -&gt; Html msg
view model args =
  div []
  [ button [ onClick (args.toSelf Clicked) ] [ &quot;Send to self&quot; ]
  , button [ onClick args.onSave ] [ text &quot;Send to parent&quot; ]
  ]
</code></pre>
<p>The parent would call this like:</p>
<pre><code class="language-haskell">module Parent exposing(..)

import Child

type Msg
  = OnSave
  | ChildMsg Child.Msg

view model =
  ...
  Child.view
    model.childModel
    { toSelf = ChildMsg
    , onSave = OnSave
    }
</code></pre>
<h1><a class="header" href="#global-actions" id="global-actions">Global actions</a></h1>
<p>If we use the nested TEA for our application, we will most likely need a way for the nested modules to communicate with the top levels. For example:</p>
<ul>
<li>Open a notification</li>
<li>Sign out the user</li>
<li>Return a value to the top level</li>
</ul>
<p>There are many way of achieving this. One possible way is to have a module with global actions e.g.</p>
<pre><code class="language-haskell">module Actions exposing (..)

type Action
	= OpenSuccessNotification ...
	| OpenFailureNotifiation ...
	| ...
</code></pre>
<p>The all your nested module will return three elements on <code>update</code>. The third one being a list of actions to execute:</p>
<pre><code class="language-haskell">update : Msg -&gt; Model -&gt; (Model, Cmd Msg, List Action)
</code></pre>
<p>Any nested module in the chain could add an action to the list.</p>
<p>Finally your root <code>update</code> will need to map through the list and process the actions.</p>
<hr />
<ul>
<li>A nice pattern for adding actions is to mimic <code>Cmd.batch</code>. E.g. <code>Actions.batch</code>.</li>
<li>We might need to send a message back to the module that returned the action. E.g. Open a dialog with selections. In this case our actions might need a message associated with them e.g. <code>Action Msg</code>. We will need a <code>Actions.map</code> to just like <code>Html.map</code>.</li>
</ul>
<h1><a class="header" href="#the-effects-pattern" id="the-effects-pattern">The effects pattern</a></h1>
<p>In a usual Elm application the <code>update</code> function returns <code>(Model, Cmd Msg)</code>. <code>Cmd</code> in Elm is an opaque type so <code>update</code> functions are not easy to test. We cannot easily inspect the commands and see if they are doing the right thing. We cannot also simulate these commands as we don't know what they are doing.</p>
<h2><a class="header" href="#pattern-11" id="pattern-11">Pattern</a></h2>
<p>The <strong>effects pattern</strong> allows us to deal with these issues by returning an <code>Effect</code> type instead of <code>Cmd msg</code> from <code>update</code>.</p>
<pre><code class="language-haskell">type Effect
	= SaveUser User
	| LogoutUser
	| LoadData
	| ...

update : Msg -&gt; Model -&gt; (Model, List Effect)
</code></pre>
<p>At the last possible moment we convert the <code>Effect</code> into actual commands. E.g. in the root module of the app we would have a function like:</p>
<pre><code class="language-haskell">runEffects : List Effect -&gt; Cmd Msg
</code></pre>
<p>This makes a Elm application a lot more testable. This is approach taken by <a href="https://elm-program-test.netlify.app/cmds.html">elm-program-test</a>.</p>
<p>Here is a more detailed <a href="http://reasonableapproximation.net/2019/10/20/the-effect-pattern.html">blog post about this pattern</a>.</p>
<h1><a class="header" href="#update-return-pipeline" id="update-return-pipeline">Update return pipeline</a></h1>
<p>Sometimes in the our update function we need to do many different things. For example:</p>
<ul>
<li>Change the state of the model</li>
<li>Change some value in the browser query</li>
<li>Conditionally load more data</li>
<li>Do some analytics tracking</li>
</ul>
<p>We can do all these things at once:</p>
<pre><code class="language-haskell">case msg of
	SeeReport report -&gt;
		let
			nextModel =
				{ model
					| stage = ReportVisible report
					, loading =
						if needsToLoadMoreData model then
							Loading
						else
							model.loading

				}
			cmd =
				Cmd.batch
					[
					if needsToLoadMoreData model then
						loadMoreDataCmd
					else
						Cmd.none
					, setSomeValueInUrl
					, TrackEvent.track {... }
					]
		in
		(nextModel, cmd)

	... -&gt;
</code></pre>
<p>But in these cases our update branches can get very complex very quickly. Making them difficult to understand and ripe for bugs.</p>
<h2><a class="header" href="#pattern-12" id="pattern-12">Pattern</a></h2>
<p>A nice way to make many things in an update branch is to break them by concerns and create a &quot;return&quot; pipeline.</p>
<pre><code class="language-haskell">case msg of
	SeeReport report -&gt;
		(model, Cmd.none)
			|&gt; andThen (setStageToReportVisible report)
			|&gt; andThen loadMoreDataIfNeeded
			|&gt; andThen addKeyInUrl
			|&gt; andThen trackSeeReportEvent
</code></pre>
<p>In this case <code>andThen</code> is a function like:</p>
<pre><code class="language-haskell">andThen : (model -&gt; (model, Cmd msg)) -&gt; (model, Cmd msg) -&gt; (model, Cmd msg)
andThen fn ( model, cmd ) =
    let
        ( nextModel, nextCmd ) =
            fn model
    in
    ( nextModel, Cmd.batch [ cmd, nextCmd ] )
</code></pre>
<p>This function takes another function that given the <code>model</code> returns a <code>(model, Cmd msg)</code> just like <code>update</code>.
<code>andThen</code> takes care of batching commands together.</p>
<p>Every function is the pipeline will be responsible for only one thing, which is a lot easier to understand. E.g.</p>
<pre><code class="language-haskell">loadMoreDataIfNeeded : Model -&gt; (Model, Cmd Msg)
loadMoreDataIfNeeded model =
	if needsToLoadMoreData model then
		({ model | loading = Loading }, loadMoreDataCmd)
	else
		(model, Cmd.none)
</code></pre>
<p><a href="https://package.elm-lang.org/packages/Fresheyeball/elm-return/">elm-return is a package that implements functions for this.</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
